---
{"dg-publish":true,"permalink":"/数据结构/时间复杂度大全/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-07-05T00:13:47.281+08:00","updated":"2024-07-05T00:13:47.281+08:00"}
---

### 单层while循环
1. 列出循环次数
2. 列出各变量在每次循环时的值
3. 根据循环退出条件列不等式
4. 写时间复杂度
### for及嵌套for循环
#### 步长为加/减法
1. 写求和表达式
2. 计算求和表达式
3. 写时间复杂度
#### 步长为乘/除法(一般为2层)
1. 写出外层循环i的变换
2. 计算内存循环的次数
3. 求和
4. 写时间复杂度
### 递归算法
#### 可用主定理
主定理 (Master Theorem) 是一种用于解决递归关系的工具，特别适用于分治算法的时间复杂度分析。它的基本形式如下：
给定一个递归关系：
$$T(n)=aT\left(\frac nb\right)+f(n)$$
其中$a\geq1$和$b>1$是常数，$f(n)$是一个渐进正函数。
主定理有三种情况：
1. 情况1：如果$f(n)=O(n^c)$,其中$c<\log_ba$ ,那么
$$T(n)=\Theta\left(n^{\log_ba}\right)$$
2. 情况2：如果$f(n)=\Theta(n^{\log_ba})$,那么
$$T(n)=\Theta\begin{pmatrix}n^{\log_ba}\log n\end{pmatrix}$$
3. 情况3：如果$f(n)=\Omega(n^c)$,其中$c>\log_ba$,并且对于某个常数$k<1$,存在$\epsilon>0$使得$af\left(\frac nb\right)\leq kf(n)$对于足够大的$n$成立，那么
$$T(n)=\Theta(f(n))$$
$Θ$ 表示渐进紧确界，即函数的上界和下界。这意味着给定的复杂度函数既是上界也是下界。在主定理中使用 $Θ$是因为主定理给出的结果不仅是时间复杂度的上界，还是紧确界。这意味着它描述的是函数的确切增长率。
#### 不可用主定理
$$T(n)=aT\left(n-b\right)+f(n)$$
1. 画树状图
2. $时间复杂度=O[T(1)]叶子数+O[f(n)]*层数$